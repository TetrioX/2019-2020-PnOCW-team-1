define('calculus', ['exports', 'differential-equations/ode45'], function (exports, _differentialEquationsOde45) {
  'use strict';

  exports.ode45 = _differentialEquationsOde45.default;
});

define("differential-equations/ode45", ["exports"], function (exports) {
  "use strict";

  var sixth = 1 / 6;

  function rungeKutta(fn, x, y, h) {
    var h2 = h * 0.5;
    var k1 = h * fn(x, y);
    var k2 = h * fn(x + h2, y + k1 * h2);
    var k3 = h * fn(x + h2, y + k2 * h2);
    var k4 = h * fn(x + h, y + k3 * h);
    return y + sixth * (k1 + 2 * k2 + 2 * k3 + k4);
  }

  function binarySearch(t, T) {
    var iMin = 0;
    var iMax = T.length - 1;
    while (iMax - iMin > 1) {
      var i = iMin + Math.round((iMax - iMin) / 2);
      var ti = T[i];
      if (ti < t) {
        iMin = i;
      } else if (ti > t) {
        iMax = i;
      } else {
        iMin = i;
        iMax = i;
      }
    }
    return [iMin, iMax];
  }

  function indexInterpolate(t, T) {
    var _binarySearch = binarySearch(t, T);

    var iMin = _binarySearch[0];
    var iMax = _binarySearch[1];

    if (iMin === iMax) {
      return iMin;
    }
    var tiMin = T[iMin];
    var tiMax = T[iMax];
    var interp = (t - tiMin) / (tiMax - tiMin);
    var index = iMin + interp;
    index = Math.min(T.length - 1, index);
    index = Math.max(0, index);
    return index;
  }

  function pluckTimes(t, T, Y) {
    var y = [];
    for (var i = 0; i < t.length; i++) {
      var ti = t[i];
      var j = indexInterpolate(ti, T);
      var jMin = Math.floor(j);
      var jMax = Math.ceil(j);
      if (jMax === j) {
        y.push(Y[j]);
      } else {
        var y1 = Y[jMin];
        var y2 = Y[jMax];
        var interp = j - jMin;
        var value = y1 + (y2 - y1) * interp;
        y.push(value);
      }
    }
    return y;
  }

  exports.indexInterpolate = indexInterpolate;
  exports.binarySearch = binarySearch;
  exports.pluckTimes = pluckTimes;

  exports.default = function (fn, domain, initial) {
    var T = [];
    var Y = [];
    var h = 1e-3;
    var yt = initial;
    var t = domain[0];
    var tMax = domain[domain.length - 1];
    Y.push(yt);
    T.push(t);
    while (t < tMax) {
      t += h;
      yt = rungeKutta(fn, t, yt, h);
      Y.push(yt);
      T.push(t);
    }

    if (domain.length > 2) {
      return [domain, pluckTimes(domain, T, Y)];
    } else {
      return [T, Y];
    }
  };
});
//# sourceMappingURL=calculus.amd.map