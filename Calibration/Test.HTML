<!DOCTYPE html>
<html>
<body>
  <canvas id="canvas" width="1000" height="600" onclick="pressButton()" style="position: absolute;
  display: block;
  top: 0px;
  left: 0px;
  transform-origin: 0 0;"></canvas>
  <script type="text/javascript">
    var th = 0;
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");

    const points = [{x: 530, y: 100}, {x: 530, y: 540}, {x: 240, y: 540}, {x: 240, y: 100}]

    var img = new Image()

    img.onload = function () {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height); // destination rectangle
    }

    img.src = 'BasisPrincipe.png';


    //
    // This code was written by nickname MvG
    //
    // For the origin of the code see:
    // @see http://jsfiddle.net/dFrHS/1/
    //
    // No license was connected to the written code below,
    // but all credits belong to the rightful owner.

    /**
     * Return the adjugate of a given matrix.
     **/
    const adj = function (m) { // Compute the adjugate of m
        return [
            m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4],
            m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5],
            m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]
        ];
    }

    /**
     * Compute the product of two given matrices.
     **/
    const multmm = function (a, b) { // multiply two matrices
        var c = Array(9);
        for (var i = 0; i != 3; ++i)
            for (var j = 0; j != 3; ++j) {
                var cij = 0;
                for (var k = 0; k != 3; ++k)
                    cij += a[3 * i + k] * b[3 * k + j];
                c[3 * i + j] = cij;
            }
        return c;
    }

    /**
     * Compute the product of a given matrix and a given vector.
     **/
    const multmv = function (m, v) { // multiply matrix and vector
        return [
            m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
            m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
            m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
        ];
    }

    /**
     * Compute the solution of the given system.
     **/
    const basisToPoints = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var m = [
            x1, x2, x3,
            y1, y2, y3,
            1, 1, 1
        ];
        var v = multmv(adj(m), [x4, y4, 1]);
        return multmm(m, [
            v[0], 0, 0,
            0, v[1], 0,
            0, 0, v[2]
        ]);
    }

    /**
     * Calculate the transformation matrix to transform given source points onto given destination points.
     **/
    const general2DProjection = function (x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d,
                                          x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
        var s = basisToPoints(x1s, y1s, x2s, y2s, x3s, y3s, x4s, y4s);
        var d = basisToPoints(x1d, y1d, x2d, y2d, x3d, y3d, x4d, y4d);
        return multmm(d, adj(s));
    }

    /**
     * Transform the given html element from a given point set to a rectangle.
     **/
    function transform2d(elt, x1, y1, x2, y2, x3, y3, x4, y4) {
        var w = window.innerWidth, h = window.innerHeight;
        var t = general2DProjection(x1, y1, 0, 0, x2, y2, w, 0, x3, y3, 0, h, x4, y4, w, h);
        for (i = 0; i != 9; ++i) t[i] = t[i] / t[8];
        t = [t[0], t[3], 0, t[6],
            t[1], t[4], 0, t[7],
            0, 0, 1, 0,
            t[2], t[5], 0, t[8]];
        t = "matrix3d(" + t.join(", ") + ")"; //setup the html 3D transformation.
        console.log(t)
        elt.style.transform = t;
    }

    function scaleCenter(center, refPicture, newPicture) {
        temp = {}
        temp.x = center.x * newPicture.x / refPicture.x;
        temp.y = center.y * newPicture.y / refPicture.y;
        return temp
    }

    function scalePoints(corners, refPicture, newPicture) {
        temp = [{}, {}, {}, {}]
        for (let i in corners) {
          console.log(temp[i])
            temp[i].x = corners[i].x * newPicture.x / refPicture.x;
            temp[i].y = corners[i].y * newPicture.y / refPicture.y;
        }
        return temp
    }

    const transformSlave = function (elt, corners, refPictureLength) {
        corners = scalePoints(corners, refPictureLength, {x: elt.width, y: elt.height})
        transform2d(elt, corners[3].x, corners[3].y, corners[0].x, corners[0].y,
            corners[2].x, corners[2].y, corners[1].x, corners[1].y);
    };

    transformSlave(canvas, points, {x: 1000, y: 600})

    function pressButton() {
      th += Math.PI/8
      if (th >= Math.PI/2) th = -Math.PI/2 + Math.PI/8
      console.log("start:", th/Math.PI)

      const f = 4322;

      result = []
      for (point of points) {
        x = f * (point.x - 1000/2) * Math.cos(th) / (f + (point.x - 1000/2) * Math.sin(th)) + 1000/2;
        y = 600/2 - f * (600/2 - point.y) / (f + (point.x - 1000/2) * Math.sin(th))
        result.push({x: x, y: y});
      }

      transformSlave(canvas, result, {x: 1000, y: 600})

    }

    function drawPolygon(pts) {
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let pt of pts)
        ctx.lineTo(pt.x,pt.y);
      ctx.stroke();
    }

  </script>
</body>
</html>
